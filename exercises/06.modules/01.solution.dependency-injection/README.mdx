# Dependency injection

I will start by creating a fake `EmailService` class in the test:

<CodeFile file="notification-service.test.ts" range="1,4-7" />

Here, I'm implementing an actual class that always stays compatible with the original `EmailService` class due to the usage of the `implements` keywords in TypeScript.

<callout-info>
  Using `implements` creates an _empty_ child class that must be type-compatible
  with the parent class. Using `extends` actually inherits the parent class'
  behaviors alongside the types.
</callout-info>

Now, I can use `EmailServiceMock` to model various behaviors in the `NotificationService` test!

I will create a new `EmailServiceMock` instance for the test case where the email must not be sent (the user didn't give their permission to receive emails):

<CodeFile file="notification-service.test.ts" range="9-19" highlight="9" />

> Note that I am not configuring any behaviors on the mocked class because _they are irrelevant for this particular test_. By taking the `EmailService` out of the testing equation, I am focusing this test strictly on the logic within `NotificationService.prototype.sendEmail` method (checking `this.preferences.email`):

<CodeFile file="notification-service.ts" range="9-17" highlight="10-12" />

In order to test the successful sending of the email, I would have to mock the return value of the `.send()` method on the respective `EmailServiceMock` instance:

<CodeFile file="notification-service.test.ts" range="21-38" highlight="22-24" />

## When to use fakes?

I can recommend using fakes if your code is already designed to support dependency injection. In that case, fakes are simple input value mocks, not that different than constructing a mocked object or a `Response` instance in tests.

However, as I said before, I would _not_ rewrite my code to support dependency injection _just for testing_. That is a dangerous mental model to adopt.

Thus, the design decisions behind your code must be based on the intention you are implementing. Rewriting the code does not improve its testability. It simply creates a different code that now requires a different test.

> :scroll: I write about code testability in [Good Code, Testable Code](https://www.epicweb.dev/good-code-testable-code). Consider reading it!
